[{"content":"競程一有講過快速傅立葉變換（fast Fourier transform；FFT），只是那時候放棄理解。\n這次修演算法又提到所以終於打算把她看懂了。\nFFT 在解決什麼問題？ ","permalink":"https://lnfu.github.io/blog/posts/2023-09-25-fft/","summary":"競程一有講過快速傅立葉變換（fast Fourier transform；FFT），只是那時候放棄理解。\n這次修演算法又提到所以終於打算把她看懂了。\nFFT 在解決什麼問題？ ","title":"快速傅立葉變換"},{"content":"一樣是隔壁朱宏國老師開的課。\n主要是教 Unity。\nUnity 基本操作  Q：View W：移動物體 E：旋轉物體 R：縮放物體  Inspector 窗格：顯示 GameObject 帶有的 Component  GameOjbect 可能是 Model、光源、Camera、粒子效果\u0026hellip;\n Component 是 GameObject 的組成元素，用來控制 GameObject 的行為，可能是：\n Transform：位置、旋轉、縮放 Mesh Filter Mesh Renderer Sphere Collider Material：材質（貼圖、反光\u0026hellip;）  Unity 遊戲設計架構 光源設定  光源越多運算成本越高\n  Type：種類（平行光、點光源、spotlight、區域光\u0026hellip;） Range：可照射的最遠距離 Angle：聚光燈展開角度 Color Mode：運算模式 Intensity：強度（亮度） Inderect Multiplier：環境光影響係數 Shadow Type：產生的影子類型 Flare：光源位置的圖像材質  Camera 可以用 Align With View 選項來套用成目前視角\nAsset Store 現在版本都只能在瀏覽器去新增\nC# Script 推薦使用 Visual Studio Code\n重要事項  當使用 public 宣告變數時（並且將 Script 套用到 GameObject），可以直接在 Inspector 窗格修改該變數。但是在 play mode 修改都不會保存。 C# 不做自動轉型！請這樣寫：float a = (float)0; float 要有 f 結尾  算數  System.Math：double UnityEngine.Mathf：float（由於 Unity 參數都是 float，所以建議使用這個就好）  using UnityEngine; public class Test : MonoBehavior { void Start() { float a = Mathf.Sin(Mathf.PI); float b = Mathf.Abs(a - 10.0f); } } 隨機 using UnityEngine; public class Test : MonoBehavior { void Start() { int seed = 40; Random.InitState(seed); float rng_1 = Random.value; // 0 ~ 1 之間（包含 0, 1）  float rng_2 = Random.Range(-5f, 5f); // -5 ~ 5 之間（包含 -5, 5）  } } 向量  Vector2 Vector3 Vector4（較少使用）  Vector3 vec = new Vector3(1.0f, 2.0f, 3.0f); Debug.Log(vec.magnitude); Debug.Log(vec.normalized); Debug.Log(vec.x); Debug.Log(vec.y); Debug.Log(vec.z); Unity C# 程式架構 所有的 script 都是繼承自 MonoBehavior 類別。他有四個 method：\n Awake()：GameObject 初始化（不需要場景其他物件資訊） Start()：GameObject 初始化（需要場景其他物件資訊） Update()：每一個 frame 呼叫一次。 FixedUpdate()：每一段時間（Fixed Timestep）呼叫一次。建議和物理運算相關的都放在這邊，精度才會好。   修改 Fixed Timestep 數值（單位是秒）：Edit -\u0026gt; Project Setting -\u0026gt; Time -\u0026gt; Fixed Timestep\n 參考官網：https://docs.unity3d.com/Manual/ExecutionOrder.html\n使用者輸入  建議將使用者輸入的判斷都放在 Update() 而不是 FixedUpdate()\n public class Test : MonoBehavior { void Update() { if (Input.anyKey) // 任何鍵盤/滑鼠按鍵按住  Debug.Log(\u0026#34;Hello\u0026#34;); Debug.Log(Input.mousePosition); // 滑鼠目前的三維座標  Debug.Log(Input.mouseScrollDelta); // 滑鼠滑動值（二維座標，普通滑鼠數值就存在 Y 座標）  if (Input.GetMouseButton(0)) // 滑鼠左鍵按住  Debug.Log(\u0026#34;Left\u0026#34;); if (Input.GetMouseButton(1)) // 滑鼠右鍵按住  Debug.Log(\u0026#34;Right\u0026#34;); if (Input.GetMouseButton(2)) // 滑鼠中鍵按住  Debug.Log(\u0026#34;Middle\u0026#34;); // 單次  if (Input.GetMouseButtonDown(0)) // 滑鼠左鍵按下（單次）  Debug.Log(\u0026#34;Left\u0026#34;); if (Input.GetMouseButtonUp(1)) // 滑鼠右鍵放開（單次）  Debug.Log(\u0026#34;Right\u0026#34;); if (Input.GetKey(KeyCode.A)) Debug.Log(\u0026#34;A/a\u0026#34;); if (Input.GetKey(KeyCode.UpArrow)) Debug.Log(\u0026#34;Up\u0026#34;); } } GameObject 兩種方式獲取：\n 宣告 public 然後透過圖形界面 asign 使用 GameObject.Find(\u0026quot;名稱\u0026quot;)（不太建議）  method：\n void SetActive(bool value)：開啟/關閉 GameObject（在遊戲中不顯示、Component 也不更新） T GetComponent\u0026lt;T\u0026gt;()：獲取 Component。其中 Component 會有 proverty 叫做 enabled（開/關 Component）  ","permalink":"https://lnfu.github.io/blog/posts/2023-09-24-game-prog/","summary":"一樣是隔壁朱宏國老師開的課。\n主要是教 Unity。\nUnity 基本操作  Q：View W：移動物體 E：旋轉物體 R：縮放物體  Inspector 窗格：顯示 GameObject 帶有的 Component  GameOjbect 可能是 Model、光源、Camera、粒子效果\u0026hellip;\n Component 是 GameObject 的組成元素，用來控制 GameObject 的行為，可能是：\n Transform：位置、旋轉、縮放 Mesh Filter Mesh Renderer Sphere Collider Material：材質（貼圖、反光\u0026hellip;）  Unity 遊戲設計架構 光源設定  光源越多運算成本越高\n  Type：種類（平行光、點光源、spotlight、區域光\u0026hellip;） Range：可照射的最遠距離 Angle：聚光燈展開角度 Color Mode：運算模式 Intensity：強度（亮度） Inderect Multiplier：環境光影響係數 Shadow Type：產生的影子類型 Flare：光源位置的圖像材質  Camera 可以用 Align With View 選項來套用成目前視角\nAsset Store 現在版本都只能在瀏覽器去新增\nC# Script 推薦使用 Visual Studio Code","title":"[課程筆記] 遊戲程式設計"},{"content":"課程網站：https://nasa.cs.nycu.edu.tw/sa/2023/\nFreeBSD 版本 ---------------------- CURRENT (14.0 2022) ---------------------- STABLE | \\---RELEASE FreeBSD-A.B.C-Type  A: major version # B: minor version # C: slight patch version # Type: PRERELEASE, BETA, RC | RELEASE | STABLE | CURRENT  uname -r # 查看版本 freebsd-version # 查看版本 (uname 和 freebsd-version 的差異)[https://forums.freebsd.org/threads/freebsd-version-1-and-uname-1-different.70294/]\nfreebsd-update fetch install # 更新系統 EoL（End-of-Life） 沒人在維護\nRELEASE 三個月 magor # 五年（LTS）\n安裝 ISO 可以到 nctu mirror 去下載，只要 disk1 就夠了，不用下載 dvd。\n新增使用者 adduser\n磁碟分割 gpart show # 顯示 partition 資訊 freebsd-boot：放 kernel freebsd-zfs：一般檔案 freebsd-swap：virtual memory\n/dev 代表 device /dev/ada0p1 磁碟 partition 1 /dev/ada0p2 磁碟 partition 1 /dev/ada0p3 磁碟 partition 1\nhttps://en.wikipedia.org/wiki/BSD_disklabel\n設定 judge 帳號免密碼登入 fetch https://nasa.cs.nctu.edu.tw/sa/2023/nasakey.pub cat nasakey.pub \u0026gt;\u0026gt; /home/judge/.ssh/authorized_keys ssh-keygen -l -f nasakey.pub 修改 sudo 權限 visudo # 等同 sudo vi /usr/local/etc/sudoers + 套用設定 sudo update-alternatives --config editor # 更改 visudo editor 補充  BIOS 是在主機板上（firmware） (1982, IBM PC 規格延續到現在) 一個 sector = 512 Bytes 磁碟分割：MBR（4 partition）、GPT（128 partition） 檔案系統：UFS（Unix File System）、ZFS（推薦使用）、ext4（Linux 使用） partition = slice 只有輪子群組可以下 su - CST 指的是台灣時區 visudo = sudo vi /usr/local/etc/sudoers + apply 如果 ping 的延遲很低，ssh 卻很慢可能是 DNS 反解問題。可以參考：https://www.ltsplus.com/linux/sshd-login-slow - config 加入 UseDNS no  ada: IDE, SATA da: SCSI, usb stick\n 從主開機紀錄的結構可以知道，它僅僅包含一個64個位元組的硬碟分割區表。由於每個分割區資訊需要16個位元組，所以對於採用MBR型分割區結構的硬碟，最多只能辨識4個主要分割區（Primary partition）。（維基百科：MBR）\n RAID = 磁碟陣列（多個硬碟） Stripe：檔案分成多塊分別同時寫到多個硬碟\n安裝軟體 pkg（package） Pre-built binary programs（已編譯）\npkg search vim pkg install vim pkg upgrade vim pkg delete vim pkg update # 更新 database pkg info # 查看已安裝的軟體 pkg version -v ports source code\n自己 compile\n其他奇奇怪怪 tarball：包起來的東西（副檔名 .tar.gz）\ntar = tape archive\nvcs = version controll system e.g., git, svn\nUbuntu Issues ZFS installer option 刪除 Desktop 相關套件\nwget instead of fetche\n","permalink":"https://lnfu.github.io/blog/posts/2023-09-21-sa/","summary":"課程網站：https://nasa.cs.nycu.edu.tw/sa/2023/\nFreeBSD 版本 ---------------------- CURRENT (14.0 2022) ---------------------- STABLE | \\---RELEASE FreeBSD-A.B.C-Type  A: major version # B: minor version # C: slight patch version # Type: PRERELEASE, BETA, RC | RELEASE | STABLE | CURRENT  uname -r # 查看版本 freebsd-version # 查看版本 (uname 和 freebsd-version 的差異)[https://forums.freebsd.org/threads/freebsd-version-1-and-uname-1-different.70294/]\nfreebsd-update fetch install # 更新系統 EoL（End-of-Life） 沒人在維護\nRELEASE 三個月 magor # 五年（LTS）\n安裝 ISO 可以到 nctu mirror 去下載，只要 disk1 就夠了，不用下載 dvd。\n新增使用者 adduser","title":"[課程筆記] 計算機系統管理（SA）"},{"content":"課程簡介：略\n電腦開機  PC = FFFF:0000 執行 BIOS（現在電腦通常改成 UEFI） 磁碟最開頭的 512 Bytes 叫做 MBR（負責尋找磁碟上的作業系統 e.g., Windows）  Interrupt handling（中斷處理） CPU 一次只能做一件事，如果有一個事情卡住，就可以透過中斷來去做別的事情。\n分成：\n 硬體中斷：e.g., IO 軟體中斷：e.g., 除以 0  這兩種中斷基本上處理的流程一樣。\n範例流程  IO device 發出中斷訊號給 PIC PIC 發中斷給 CPU CPU 把目前在處理的東西（當前狀態 e.g., program counter, \u0026hellip;）先存起來 CPU 查詢 IVT（interrupt vector table） 後跳到對應的 ISR（interrupt service routine） 執行 ISR 最後一個指令會是 IRET（return 回原本 CPU 處理的東西）   IVT（中斷向量表）。位置固定（方便 CPU 查詢），通常放在記憶體位置為 0。\n  作業系統（or 驅動程式）要負責 ISR 的部份。\n  不要忘記會有延遲（latency ）\n I/O 一個 IO 基本上最花時間的部份是：\n 在 IO device 處理的時間 IO device 傳到 memory 的 data transfer 時間  DMA 負責從 IO device（e.g., 磁碟）到 buffer in memory 的高速傳輸。（傳完送 inturrupt 給 CPU）\nSync（blocking） vs. Async（non-blocking） I/O    Function sync or async? 說明     read() sync 進行讀的 process 會需要 wait，CPU 會在這時去跑其他的 process。   write() async    fsync() sync system call。可以看成 sync 版本的 write。   aio_read() async async 的 read，用來做作 prefetch。     system call：kernel 提供的服務\n multiprogramming process = job = task\n為什麼要很多的 process？ 像是前面提到屬於 sync 的 read()，如果 CPU 執行時遇到就會 blocking，此時若能利用這個 wait 的時間去執行其他的 process 就能節省時間。\ntimesharing 除了前面所說 blocking 切換 process，經過一段固定的時間（透過 timer）自動切換到下一個 process。 如此一來可以達到像是均勻分配的效果。\ntime slice = time quantum\n結論：timesharing ⊂ multitasking ⊂ multiprogramming  multiprogramming：載入很多 process 到 memory multitasking：multiprogramming 有 overlapped timesharing：要有 periodic switch  ","permalink":"https://lnfu.github.io/blog/posts/2023-09-18-os/","summary":"課程簡介：略\n電腦開機  PC = FFFF:0000 執行 BIOS（現在電腦通常改成 UEFI） 磁碟最開頭的 512 Bytes 叫做 MBR（負責尋找磁碟上的作業系統 e.g., Windows）  Interrupt handling（中斷處理） CPU 一次只能做一件事，如果有一個事情卡住，就可以透過中斷來去做別的事情。\n分成：\n 硬體中斷：e.g., IO 軟體中斷：e.g., 除以 0  這兩種中斷基本上處理的流程一樣。\n範例流程  IO device 發出中斷訊號給 PIC PIC 發中斷給 CPU CPU 把目前在處理的東西（當前狀態 e.g., program counter, \u0026hellip;）先存起來 CPU 查詢 IVT（interrupt vector table） 後跳到對應的 ISR（interrupt service routine） 執行 ISR 最後一個指令會是 IRET（return 回原本 CPU 處理的東西）   IVT（中斷向量表）。位置固定（方便 CPU 查詢），通常放在記憶體位置為 0。\n  作業系統（or 驅動程式）要負責 ISR 的部份。","title":"[課程筆記] 作業系統概論"},{"content":"Barabasi 課本： http://networksciencebook.com/chapter/0\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-25-network/","summary":"Barabasi 課本： http://networksciencebook.com/chapter/0","title":"Network"},{"content":"RAM Random Access Machine\n 記憶體存取都是花費一單位的時間 指令依序一個一個的被讀取  T(n) Running Time（步驟的總數量）\nn = input size\nComplexity of Recurrence Relation 可以參考：\n https://mycollegenotebook.medium.com/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-%E9%81%9E%E8%BF%B4-%E4%B8%8A-f6d51a462394 https://mycollegenotebook.medium.com/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-%E9%81%9E%E8%BF%B4-%E4%B8%8B-master-th-307ad4608ab6  以 merge sort 舉例，每個 sorting problem 可以拆成兩個 sorting problem，其花費的時間是原本的一半，所以 a = 2、b = 2，另外拆開（divide）的時間只需要 O(1)，合併（combine）則需要迴圈跑過一次所以是 O(n)。\n要解出 recurrence 複雜度的一般式有兩個方法：\n backward substitution Master Theorem  substitution method 用數學歸納法（strong induction）證明。\n 可以先用 recursion-tree 去分析\n -\u0026gt; 2023.08.25\nMaster Theorem Divide and Conquer Merge Sort  分成一半來 sort（recursive） 用 T(n) = n 跑過一次比較誰先誰後  T(n) = 2 T(n/2) + O(n) Binary Search Find an element in a sorted array.\nT(n) = T(n/2) + Theta(1) Power（次方） 分成奇偶 case。\nT(n) = T(n/2) + Theta(1) T(n) = Theta(lg(n)) Fibonacci 可以參考 https://zh.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0\n最慢的解法（一般式）： Omega(phi^n) Bottom-up：\nTheta(n) 矩陣（線性代數）： 然後用前面提到的 divide and conquer 算次方。\nTheta(lg(n)) * Maximum Subarray  首先可以觀察到答案的左右兩側一定是負數\n 答案一定要麼在\n 左邊子序列 右邊子序列 橫跨左右（可以從中間往左右兩邊去找）  FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high) // Find a maximum subarray of the form A[i ... mid]. leftsum = - sum = 0 for i = mid downto low sum = sum + A[i] if sum \u0026gt; leftsum leftsum = sum maxleft = i // Find a maximum subarray of the form A[mid + 1.. j]. rightsum = - sum = 0 for j = mid + 1 to high sum = sum + A[j] if sum \u0026gt; rightsum rightsum = sum maxright = j // Return the indices and the sum of the two subarrays. return (maxleft, maxright, leftsum + rightsum) FIND-MAXIMUM-SUBARRAY(A, low, high) if high == low return (low, high, A[low]) // base case: only one element else mid = (low +high)/2 (leftlow, lefthigh, leftsum) = FIND-MAXIMUM-SUBARRAY(A, low, mid) (rightlow, righthigh, rightsum) = FIND-MAXIMUM-SUBARRAY(A, mid + 1, high) (crosslow, crosshigh, crosssum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high) if leftsum \u0026gt;= rightsum and leftsum \u0026gt;= crosssum return (leftlow, lefthigh, leftsum) else if rightsum \u0026gt;= leftsum and rightsum \u0026gt;= crosssum return (rightlow, righthigh, rightsum) else return (crosslow, crosshigh, crosssum) Initial call: FIND-MAXIMUM-SUBARRAY(A, 1, n) 矩陣乘法 基本： D\u0026amp;C：\nT(n) = 8 T(n/2) + Theta(n^2) 也是 Theta(n^3)，沒有比較快 Strassen D\u0026amp;C：\nT(n) = 7 T(n/2) + Theta(n^2) 變成 Theta(n^lg(7)) = Theta(n^2.81) 目前最快解法（2.376）：https://people.csail.mit.edu/virgi/matrixmult-f.pdf\nH Tree H Tree 是一種碎形。 可以參考：https://en.wikipedia.org/wiki/H_tree\n-\u0026gt; 2023.09.21\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-25-algo/","summary":"RAM Random Access Machine\n 記憶體存取都是花費一單位的時間 指令依序一個一個的被讀取  T(n) Running Time（步驟的總數量）\nn = input size\nComplexity of Recurrence Relation 可以參考：\n https://mycollegenotebook.medium.com/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-%E9%81%9E%E8%BF%B4-%E4%B8%8A-f6d51a462394 https://mycollegenotebook.medium.com/%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-%E9%81%9E%E8%BF%B4-%E4%B8%8B-master-th-307ad4608ab6  以 merge sort 舉例，每個 sorting problem 可以拆成兩個 sorting problem，其花費的時間是原本的一半，所以 a = 2、b = 2，另外拆開（divide）的時間只需要 O(1)，合併（combine）則需要迴圈跑過一次所以是 O(n)。\n要解出 recurrence 複雜度的一般式有兩個方法：\n backward substitution Master Theorem  substitution method 用數學歸納法（strong induction）證明。\n 可以先用 recursion-tree 去分析\n -\u0026gt; 2023.08.25\nMaster Theorem Divide and Conquer Merge Sort  分成一半來 sort（recursive） 用 T(n) = n 跑過一次比較誰先誰後  T(n) = 2 T(n/2) + O(n) Binary Search Find an element in a sorted array.","title":"[課程筆記] 演算法概論"},{"content":"這是隔壁的課，不知道可不可以承認\u0026hellip;\n2023-08-25 這門課主要是講解如何使用 OpenGL。（理論的東西好像是在另一門課）\n這禮拜先講了 Transformation 和座標系等簡單的數學。\nTransformation 我們這邊討論的 transformation 就是指在 3D 座標下的幾何轉換。\n我們會用 homogeneous coordinate 來表示點和向量（w = 1 是點；w = 0 是向量）。\nOpenGL 有三個重要的矩陣：MVP matrices（model, view, projection）。\n OpenGL 的矩陣是 column major order。  常見的矩陣有：\n identity（單位矩陣）：沒有任何作用 translation（位移） scaling（縮放）：對向量來說，如果不是等比例的縮放會改變方向（寫程式時要注意） rotation（旋轉）：剛體。對於尤拉角（Euler Angle）表示，可能會導致所謂的 gimbal lock，解決方式是引入 quaternion。（有點複雜，之後研究）  https://youtu.be/zjMuIxRvygQ\nProjection 這門課只介紹了兩種投影：orthographic 和 perspective。\n perspective 的那個斷頭角錐稱作 frustum\n 比較需要注意的是，不要因為方便就把 far plane 設定超級大，這樣會因為 near plane 和 far plane 距離過大導致壓縮後太靠近加上精度問題就會有 z fighting 的問題。\n在 OpenGL 中，projection 的階段還會把座標從右手座標（RHC）轉成左手座標（LHC），最終結果會是一個 [-1, 1][-1, 1][-1, 1] 的立方體。\n結論＆作業 實際在撰寫程式時，我們會在主程式預先算好 MVP 矩陣，在 GLSL 對每個點去乘這個矩陣，結果放到 gl_Position 變數以描述所有點在 clip space 的位置。\n 推導 orthographic 和 perspective projection 的矩陣 推導 view matrix  學分太多，決定不修這門課了 ","permalink":"https://lnfu.github.io/blog/posts/2023-08-25-intro-to-graphic-prog-and-app/","summary":"這是隔壁的課，不知道可不可以承認\u0026hellip;\n2023-08-25 這門課主要是講解如何使用 OpenGL。（理論的東西好像是在另一門課）\n這禮拜先講了 Transformation 和座標系等簡單的數學。\nTransformation 我們這邊討論的 transformation 就是指在 3D 座標下的幾何轉換。\n我們會用 homogeneous coordinate 來表示點和向量（w = 1 是點；w = 0 是向量）。\nOpenGL 有三個重要的矩陣：MVP matrices（model, view, projection）。\n OpenGL 的矩陣是 column major order。  常見的矩陣有：\n identity（單位矩陣）：沒有任何作用 translation（位移） scaling（縮放）：對向量來說，如果不是等比例的縮放會改變方向（寫程式時要注意） rotation（旋轉）：剛體。對於尤拉角（Euler Angle）表示，可能會導致所謂的 gimbal lock，解決方式是引入 quaternion。（有點複雜，之後研究）  https://youtu.be/zjMuIxRvygQ\nProjection 這門課只介紹了兩種投影：orthographic 和 perspective。\n perspective 的那個斷頭角錐稱作 frustum\n 比較需要注意的是，不要因為方便就把 far plane 設定超級大，這樣會因為 near plane 和 far plane 距離過大導致壓縮後太靠近加上精度問題就會有 z fighting 的問題。\n在 OpenGL 中，projection 的階段還會把座標從右手座標（RHC）轉成左手座標（LHC），最終結果會是一個 [-1, 1][-1, 1][-1, 1] 的立方體。","title":"[課程筆記] 繪圖程式設計與應用"},{"content":"平常在進行後端開發時，我們通常會在本地開一個資料庫（的容器）做測試，這篇主要是介紹一個可以比較快速且有邏輯建立好整個資料庫作為開發使用，並且透過所謂的 migration 以及腳本化達到重複使用（reuse）。\n正題 先到 https://dbdiagram.io/ 建立 Diagram，匯出 PDF 和 SQL 檔案。\n 語法請參考 dbdiagram 官方說明文件。\n 其中 PDF 檔案可以在和別人討論資料庫設計時使用（或是也可以匯出成圖片）；SQL 檔案在之後的 migration 會用到。\n使用 node-pg-migrate 輕鬆管理開發時本地資料庫的表格（migration）。\nyarn add pg yarn add node-pg-migrate yarn node-pg-migrate create init 這樣操作完後會建立一個 migrations/xxxxxxxxxxxxx_init.js 檔案。\n然後就可以把一開始匯出的 SQL 檔案內容貼到 migrate up 的部份，並且在 migrate down 撰寫好 drop table（記得順序要和 create table 顛倒以解決表格間衝突的問題）。\n記得設定 package.json 的 scirpt 簡化所有操作。\n \u0026quot;scripts\u0026quot;: { \u0026quot;dev\u0026quot;: \u0026quot;node app.js\u0026quot;, \u0026quot;postgres\u0026quot;: \u0026quot;sudo docker run --name postgres15 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=secret -d postgres:15-alpine\u0026quot;, \u0026quot;createdb\u0026quot;: \u0026quot;sudo docker exec postgres15 createdb --username=root --owner=root note\u0026quot;, \u0026quot;dropdb\u0026quot;: \u0026quot;sudo docker exec postgres15 dropdb note\u0026quot;, \u0026quot;migrate\u0026quot;: \u0026quot;DATABASE_URL=postgres://root:secret@localhost:5432/note node-pg-migrate\u0026quot; } 另外 SQL Client 推薦 open source 的軟體 DBeaver，雖然目前用下來好像 tableplus（非 open source）比較好用\u0026hellip;\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-25-backend-nodejs-postgresql/","summary":"平常在進行後端開發時，我們通常會在本地開一個資料庫（的容器）做測試，這篇主要是介紹一個可以比較快速且有邏輯建立好整個資料庫作為開發使用，並且透過所謂的 migration 以及腳本化達到重複使用（reuse）。\n正題 先到 https://dbdiagram.io/ 建立 Diagram，匯出 PDF 和 SQL 檔案。\n 語法請參考 dbdiagram 官方說明文件。\n 其中 PDF 檔案可以在和別人討論資料庫設計時使用（或是也可以匯出成圖片）；SQL 檔案在之後的 migration 會用到。\n使用 node-pg-migrate 輕鬆管理開發時本地資料庫的表格（migration）。\nyarn add pg yarn add node-pg-migrate yarn node-pg-migrate create init 這樣操作完後會建立一個 migrations/xxxxxxxxxxxxx_init.js 檔案。\n然後就可以把一開始匯出的 SQL 檔案內容貼到 migrate up 的部份，並且在 migrate down 撰寫好 drop table（記得順序要和 create table 顛倒以解決表格間衝突的問題）。\n記得設定 package.json 的 scirpt 簡化所有操作。\n \u0026quot;scripts\u0026quot;: { \u0026quot;dev\u0026quot;: \u0026quot;node app.js\u0026quot;, \u0026quot;postgres\u0026quot;: \u0026quot;sudo docker run --name postgres15 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=secret -d postgres:15-alpine\u0026quot;, \u0026quot;createdb\u0026quot;: \u0026quot;sudo docker exec postgres15 createdb --username=root --owner=root note\u0026quot;, \u0026quot;dropdb\u0026quot;: \u0026quot;sudo docker exec postgres15 dropdb note\u0026quot;, \u0026quot;migrate\u0026quot;: \u0026quot;DATABASE_URL=postgres://root:secret@localhost:5432/note node-pg-migrate\u0026quot; } 另外 SQL Client 推薦 open source 的軟體 DBeaver，雖然目前用下來好像 tableplus（非 open source）比較好用\u0026hellip;","title":"Node.js 和 PostgreSQL 的小技巧"},{"content":"Javascript 的 Array（陣列）有幾個特點。\n 元素可以是任意型別。例如 arr[0] = 0; arr[1] = 'hello' 元素預設值是 undefined 陣列的長度是可變的  要知道哪些 index 有值（不是 undefined）：\nObject.keys(arr) Method Array.at(idx) 使用 .at() 而不是中括號的好處是允許負數（代表從後面數）\nArray.concat(value1, value2, \u0026hellip;) 參數可以是新增的元素也可以是陣列。（都會直接接在後面）。\n如果沒有給參數就是回傳一個 shallow copy。\n For shallow copies, only the top-level properties are copied, not the values of nested objects. Therefore:\n   Re-assigning top-level properties of the copy does not affect the source object. Re-assigning nested object properties of the copy does affect the source object.   Array.fill(value, start, end) 和 Array.copyWithin(target, start, end)  [start, end) 右邊是開區間\n Array.fill() 是將陣列從 start 到 end 填上 value。\nArray.copyWithin() 是將陣列複製一份（從 start 到 end）並以 target 為起點貼上，超出陣列長度的部份就直接省略。\n 這個函數我還真不知道什麼時候會用到哈哈。\n Array.fill(value) Array.fill(value, start) Array.fill(value, start, end) Array.copyWithin(target) Array.copyWithin(target, start) Array.copyWithin(target, start, end) Array.entries() 回傳 iterator，那個 next() 一定要寫。\nconst array1 = ['a', , 'c']; const iterator1 = array1.entries(); console.log(iterator1.next().value); console.log(iterator1.next().value); console.log(iterator1.next().value); 結果：\n\u0026gt; Array [0, \u0026quot;a\u0026quot;] \u0026gt; Array [1, undefined] \u0026gt; Array [2, \u0026quot;c\u0026quot;] Array.every(callbackFn) 是否所有元素都滿足 callbackFn，回傳 true / false。\nArray.filter(callbackFn) 返回一個滿足 callbackFn 的元素所組成的 shallow copy 陣列。\nfind 系列  Array.find() 返回第一個滿足 callbackFn 的元素（的值）。 Array.findLast() 返回從後面數第一個滿足 callbackFn 的元素（的值）。 Array.findIndex() 返回第一個滿足 callbackFn 的元素（的索引）。 Array.findLastIndex() 返回從後面數第一個滿足 callbackFn 的元素（的索引）。  ","permalink":"https://lnfu.github.io/blog/posts/2023-08-23-js-array/","summary":"Javascript 的 Array（陣列）有幾個特點。\n 元素可以是任意型別。例如 arr[0] = 0; arr[1] = 'hello' 元素預設值是 undefined 陣列的長度是可變的  要知道哪些 index 有值（不是 undefined）：\nObject.keys(arr) Method Array.at(idx) 使用 .at() 而不是中括號的好處是允許負數（代表從後面數）\nArray.concat(value1, value2, \u0026hellip;) 參數可以是新增的元素也可以是陣列。（都會直接接在後面）。\n如果沒有給參數就是回傳一個 shallow copy。\n For shallow copies, only the top-level properties are copied, not the values of nested objects. Therefore:\n   Re-assigning top-level properties of the copy does not affect the source object. Re-assigning nested object properties of the copy does affect the source object.","title":"Javascript 陣列筆記"},{"content":"官方 Github 上面寫 axios 是 promise based HTTP client。\n 可以複習一下 javascript promise 語法\n  axios 是前端的技術。（透過 axois 獲取後端 api 提供的資料）\n axios 和 fetch 都可以拿來進行 HTTP request（而且都是 async），主要差異如下：\n axios 語法上稍微方便一些（只有一點點，可以自己去比較） fetch 在現在的瀏覽器基本上都是內建的，所以不用像 axios 還要引入第三方套件。   這樣看下來我先弄熟 fetch 就好了\u0026hellip;\n 使用 @html\n\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; axios.get('https://randomuser.me/api/) .then(res =\u0026gt; { console.log(res.data.results) }) .catch(err =\u0026gt; { console.log(err.response) }) \u0026lt;/script\u0026gt; ","permalink":"https://lnfu.github.io/blog/posts/2023-08-23-axios/","summary":"官方 Github 上面寫 axios 是 promise based HTTP client。\n 可以複習一下 javascript promise 語法\n  axios 是前端的技術。（透過 axois 獲取後端 api 提供的資料）\n axios 和 fetch 都可以拿來進行 HTTP request（而且都是 async），主要差異如下：\n axios 語法上稍微方便一些（只有一點點，可以自己去比較） fetch 在現在的瀏覽器基本上都是內建的，所以不用像 axios 還要引入第三方套件。   這樣看下來我先弄熟 fetch 就好了\u0026hellip;\n 使用 @html\n\u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; axios.get('https://randomuser.me/api/) .then(res =\u0026gt; { console.log(res.data.results) }) .catch(err =\u0026gt; { console.log(err.response) }) \u0026lt;/script\u0026gt; ","title":"Axios 介紹"},{"content":"DOM Manipulation document.getElementById() document.getElementByClassName() document.getElementByTagName() document.querySelector() document.getElementById() ","permalink":"https://lnfu.github.io/blog/posts/2023-08-22-dom/","summary":"DOM Manipulation document.getElementById() document.getElementByClassName() document.getElementByTagName() document.querySelector() document.getElementById() ","title":"2023 08 22 Dom"},{"content":"這個暑假原本雄心壯志的規劃要學很多東西，無奈中間遇到車禍整個打亂，加上自己的惰性浪費了好多時間。\n這篇的目的是希望能在開學前至少做一些東西出來。\n網站程式學習  CORS  簡介✅ 實做   Javascript Array Method  看完 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array 整理   axios  簡介✅   Insomnia  就是一個好用的 API testing 桌面軟體✅ 還有另一個比較多人使用的軟體是 Postman✅   react hooks eslint, prettier Material UI, Tailwindcss, DnD library Redux, Zustand NextJS Authentication：oauth 2, jwt（可以參考 CSCC 文章）   其他  2023.08.31 雪山  影片 文字紀錄   2023.09.04 花蓮 2023.09.07 台南  ","permalink":"https://lnfu.github.io/blog/posts/2023-08-22-august-plan/","summary":"這個暑假原本雄心壯志的規劃要學很多東西，無奈中間遇到車禍整個打亂，加上自己的惰性浪費了好多時間。\n這篇的目的是希望能在開學前至少做一些東西出來。\n網站程式學習  CORS  簡介✅ 實做   Javascript Array Method  看完 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array 整理   axios  簡介✅   Insomnia  就是一個好用的 API testing 桌面軟體✅ 還有另一個比較多人使用的軟體是 Postman✅   react hooks eslint, prettier Material UI, Tailwindcss, DnD library Redux, Zustand NextJS Authentication：oauth 2, jwt（可以參考 CSCC 文章）   其他  2023.08.31 雪山  影片 文字紀錄   2023.09.04 花蓮 2023.09.07 台南  ","title":"八月底計畫"},{"content":"CI/CD（持續整合 / 持續部屬）是 DevOps 的概念。\n所謂 DevOps 指的是把開發（development）和運維（operation）結合。也可以看成是自動化運維。\n一般來說流程如下：\n 開發人員將撰寫好的程式碼 push 到 git repo git repo 透過 git hook 自動進行 build / test / deploy  目前最廣泛被使用的 CI/CD 工具是 Jenkins。\n 其他還有 Travis-Ci、CircleCI\n Jenkins 使用教學 未完\u0026hellip;\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-22-cicd/","summary":"CI/CD（持續整合 / 持續部屬）是 DevOps 的概念。\n所謂 DevOps 指的是把開發（development）和運維（operation）結合。也可以看成是自動化運維。\n一般來說流程如下：\n 開發人員將撰寫好的程式碼 push 到 git repo git repo 透過 git hook 自動進行 build / test / deploy  目前最廣泛被使用的 CI/CD 工具是 Jenkins。\n 其他還有 Travis-Ci、CircleCI\n Jenkins 使用教學 未完\u0026hellip;","title":"CI/CD"},{"content":"CORS（cross-origin resource sharing） = 跨來源資源共享。\n所謂同源（same origin）指的是符合三格條件：\n same protocol same domain same port  例如我們在 google.com 要請求 facebook.com 的資源就是屬於 CORS，因此會被 CORS policy 阻止。\n 可以在 google.com 開啟 F12 \u0026gt; console\n fetch(\u0026quot;https://www.facebook.com\u0026quot;) 結果：\nPromise {\u0026lt;pending\u0026gt;} [[Prototype]]: Promise [[PromiseState]]: \u0026quot;rejected\u0026quot; [[PromiseResult]]: TypeError: Failed to fetch at \u0026lt;anonymous\u0026gt;:1:1 Access to fetch at 'https://www.facebook.com/' from origin 'https://www.google.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled. GET https://www.facebook.com/ net::ERR_FAILED 200 如果只是單純請求 google.com 下的資源就不是 CORS。\nfetch(\u0026quot;https://www.google.com\u0026quot;) 結果：\nPromise {\u0026lt;pending\u0026gt;} [[Prototype]]: Promise [[PromiseState]]: \u0026quot;fulfilled\u0026quot; [[PromiseResult]]: Response 為什麼要有 CORS policy？ 假設沒有 CORS policy，當我們到一個不安全的網站時，它就可以直接存取（access）我們在其他網站的資料（例如銀行網站）。\n那如果我真的想要進行 CORS 呢？ 解法一：允許 CORS 我們可以在 response header 加上\nAccess-Control-Allow-Origin: \u0026lt;origin\u0026gt;  \u0026lt;origin\u0026gt; 可以是 * 代表允許所有來源的 cors\n 解法二：Jsonp 前面提到什麼是 CORS 時你可能會好奇，為什麼我們在 HTML 使用 img, iframe, script 等標籤時不會有 CORS 的問題。事實上，這三種標籤正是透過 Jsonp 來達到 CORS（src 屬性）。\n實際應用範例 未完\u0026hellip;\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-22-cors/","summary":"CORS（cross-origin resource sharing） = 跨來源資源共享。\n所謂同源（same origin）指的是符合三格條件：\n same protocol same domain same port  例如我們在 google.com 要請求 facebook.com 的資源就是屬於 CORS，因此會被 CORS policy 阻止。\n 可以在 google.com 開啟 F12 \u0026gt; console\n fetch(\u0026quot;https://www.facebook.com\u0026quot;) 結果：\nPromise {\u0026lt;pending\u0026gt;} [[Prototype]]: Promise [[PromiseState]]: \u0026quot;rejected\u0026quot; [[PromiseResult]]: TypeError: Failed to fetch at \u0026lt;anonymous\u0026gt;:1:1 Access to fetch at 'https://www.facebook.com/' from origin 'https://www.google.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.","title":"CORS"},{"content":"K8S（Kubernetes）是 Google 開發出來用於調度容器（container）的系統。\n container 和 VM 最大的差別在於沒有 Guest OS（軟體層級的虛擬化）\n K8S 的節點（node）分成兩種：control plane 和 worker node。\n 可以理解節點 = 機器（machine）\n Control Plane 負責管理整個集群（cluster）。\n 以前叫做 master\n 四大元件：\n API Server：負責處理和使用者以及和 worker node 交互的伺服器  使用者可以透過 kubectl / RestfulAPI / Web UI 和 control plane 交互   Etcd：儲存各種 metadata 的資料庫  例如儲存各個 worker node 狀態   Scheduler：負責把 Pod 分配到 node 上面（調度） Controller Manager：負責監控整個 cluster 狀態並做出反應。  Worker Node 三個 process：\n Kubelet：和 control plane 的 API server 溝通 Kube-proxy：負責虛擬網卡（給予 container 網路） Container Runtime  CRI kubelet 透過 CRI 呼叫 container runtime\n常見有：\n Docker（已經不支援） containerd CRI-O   CRI 屬於 high level 的 container runtime 規範，OCI 屬於 low level（e.g., runC, Crun）\n  Crun 在效率上比 runC 高\n CNI 負責 container 之間、跨節點的網路連接\n常見有：\n Flannel  Control Plane High Avalability (HA) 可以透過 HAProxy + Keepalived 達到 control plane 的 HA\n 目前理解 HAProxy 是 load balancer、Keepalived 會負責檢查機器並且決定主要伺服器。\n Pod K8S 基本單位。\n一個 pod 可以有多個 container（雖然常常只有一個）。 這些 container 有獨立的 pid, mnt namespace，但是共用 net, uts, ipc namespace。（共享網路\u0026hellip;）\nStatic Pod 固定在節點上執行。 kubelet 監控、管理。（刪除結束會重啟）\ngrafana apiVersion: v1 data: grafana.ini: | [analytics] check_for_updates = true [grafana_net] url = https://grafana.net [log] mode = console level = debug [paths] data = /var/lib/grafana/ logs = /var/log/grafana plugins = /var/lib/grafana/plugins provisioning = /etc/grafana/provisioning [server] domain = 'grafana.efliao.test.cc.cs.nctu.edu.tw' root_url = 'http://grafana.efliao.test.cc.cs.nctu.edu.tw' # http_port = 30678 [auth.generic_oauth] email_attribute_name = uid tls_skip_verify_insecure = true enabled = true client_id = 285 client_secret = ykweRHC0o4pEshJyOOGCPWC8JK3AnjGSIRXrczBY scopes = openid email auth_url = \u0026quot;http://oauth.alpha.test.cc.cs.nctu.edu.tw/oauth/authorize?\u0026quot; token_url = \u0026quot;http://oauth.alpha.test.cc.cs.nctu.edu.tw/oauth/token\u0026quot; api_url = \u0026quot;http://oauth.alpha.test.cc.cs.nctu.edu.tw/api/user\u0026quot; kind: ConfigMap ","permalink":"https://lnfu.github.io/blog/posts/2023-08-17-k8s-overview/","summary":"K8S（Kubernetes）是 Google 開發出來用於調度容器（container）的系統。\n container 和 VM 最大的差別在於沒有 Guest OS（軟體層級的虛擬化）\n K8S 的節點（node）分成兩種：control plane 和 worker node。\n 可以理解節點 = 機器（machine）\n Control Plane 負責管理整個集群（cluster）。\n 以前叫做 master\n 四大元件：\n API Server：負責處理和使用者以及和 worker node 交互的伺服器  使用者可以透過 kubectl / RestfulAPI / Web UI 和 control plane 交互   Etcd：儲存各種 metadata 的資料庫  例如儲存各個 worker node 狀態   Scheduler：負責把 Pod 分配到 node 上面（調度） Controller Manager：負責監控整個 cluster 狀態並做出反應。  Worker Node 三個 process：","title":"K8S 簡介"},{"content":"stack：Vite + React\nyarn add tailwindcss postcss autoprefixer --dev npx tailwindcss init -p 修改 tailwind.config.js（content 的值）。\n/** @type {import('tailwindcss').Config} */ export default { content: [ \u0026quot;./index.html\u0026quot;, \u0026quot;./src/**/*.{js,ts,jsx,tsx}\u0026quot;, ], theme: { extend: {}, }, plugins: [], } 修改 src/index.css（Vite 預設的內容都直接刪掉就好）。\n@tailwind base; @tailwind components; @tailwind utilities; ","permalink":"https://lnfu.github.io/blog/posts/2023-08-16-tailwindcss/","summary":"stack：Vite + React\nyarn add tailwindcss postcss autoprefixer --dev npx tailwindcss init -p 修改 tailwind.config.js（content 的值）。\n/** @type {import('tailwindcss').Config} */ export default { content: [ \u0026quot;./index.html\u0026quot;, \u0026quot;./src/**/*.{js,ts,jsx,tsx}\u0026quot;, ], theme: { extend: {}, }, plugins: [], } 修改 src/index.css（Vite 預設的內容都直接刪掉就好）。\n@tailwind base; @tailwind components; @tailwind utilities; ","title":"Tailwind CSS 基本使用"},{"content":"tmux 是一個管理終端的工具。\n有了 tmux，我們可以很輕鬆的新增、切換終端，甚至是平鋪終端。\n名詞 session, window, pane\n基本使用  Ctrl + b + %：新增水平 pane Ctrl + b + \u0026quot;：新增垂直 pane  https://www.ruanyifeng.com/blog/2019/10/tmux.html\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-16-tmux/","summary":"tmux 是一個管理終端的工具。\n有了 tmux，我們可以很輕鬆的新增、切換終端，甚至是平鋪終端。\n名詞 session, window, pane\n基本使用  Ctrl + b + %：新增水平 pane Ctrl + b + \u0026quot;：新增垂直 pane  https://www.ruanyifeng.com/blog/2019/10/tmux.html","title":"2023 08 16 Tmux"},{"content":"從 class 到 arrow function 之前在寫 React 時，我都使用 class extends React.Component 的寫法。\n然而在有些時候，單純使用 arrow function 的寫法會更為簡潔。\n不過如果一來要使用到 state 的功能就沒辦法直接在 class 裡面寫了。（已經沒有 class）\n這時候我們可以引入 React Hooks 來使用 state。\n使用範例 我們可以先練習從熟悉的 class 寫法來一步一步改成使用 arrow function + React Hooks 的寫法。\n假設有以下 component：\nclass App extends React.Component { constructor(props) { super(props) this.state = { message: \u0026quot;\u0026quot; } this.greet = this.greet.bind(this) } greet() { this.setState({ message: \u0026quot;Hello, World\u0026quot; }) } render() { return \u0026lt;\u0026gt; \u0026lt;button onClick={this.greet}\u0026gt;Hello\u0026lt;/button\u0026gt; \u0026lt;h1\u0026gt;{this.state.message}\u0026lt;/h1\u0026gt; \u0026lt;/\u0026gt; } } 我們可以先把 class 改寫成 arrow function。\nconst App = (props) =\u0026gt; { ; } 接著把 render() 函數裡面的內容拉出來到 App()，然後刪除 render() 和 constructor()。\nconst App = (props) =\u0026gt; { return \u0026lt;\u0026gt; \u0026lt;button onClick={this.greet}\u0026gt;Hello\u0026lt;/button\u0026gt; \u0026lt;h1\u0026gt;{this.state.message}\u0026lt;/h1\u0026gt; \u0026lt;/\u0026gt; } 然後我們使用 useState() 來新增一個 state。\n 記得要 import useState()。\n  useState() 裡面的參數是 state 的預設值。\n const [ message, setMessage ] = useState(\u0026quot;\u0026quot;) 然後改寫 greet() 函數。\nconst greet = () =\u0026gt; { setMessage(\u0026quot;Hello, World\u0026quot;) } 最後我們把原本 class 需要寫的 this 刪除，並且原本的 this.state 的遺跡改成直接使用 message。\nconst App = (props) =\u0026gt; { const [ message, setMessage ] = useState(\u0026quot;\u0026quot;) const greet = () =\u0026gt; { setMessage(\u0026quot;Hello, World\u0026quot;) } return \u0026lt;\u0026gt; \u0026lt;button onClick={greet}\u0026gt;Hello\u0026lt;/button\u0026gt; \u0026lt;h1\u0026gt;{message}\u0026lt;/h1\u0026gt; \u0026lt;/\u0026gt; } 這樣改完後是不是變得超級簡潔！如果想要再更精簡一點，我們也可以把 greet() 寫成在 onClick 後面。\nonClick={() =\u0026gt; {setMessage(\u0026quot;Hello, World\u0026quot;)}} 心得 想當初看別人寫 React 也是都用 useState() 的方式，但是學習時卻發現有點卡卡的，所以還是建議一開始學 React 的朋友可以先從最初的 class 寫法下手。 等到對整個架構稍微熟悉後再去改成使用 arrow function 和 React Hooks 的寫法就會非常簡潔。\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-14-react-hooks-usestate/","summary":"從 class 到 arrow function 之前在寫 React 時，我都使用 class extends React.Component 的寫法。\n然而在有些時候，單純使用 arrow function 的寫法會更為簡潔。\n不過如果一來要使用到 state 的功能就沒辦法直接在 class 裡面寫了。（已經沒有 class）\n這時候我們可以引入 React Hooks 來使用 state。\n使用範例 我們可以先練習從熟悉的 class 寫法來一步一步改成使用 arrow function + React Hooks 的寫法。\n假設有以下 component：\nclass App extends React.Component { constructor(props) { super(props) this.state = { message: \u0026quot;\u0026quot; } this.greet = this.greet.bind(this) } greet() { this.setState({ message: \u0026quot;Hello, World\u0026quot; }) } render() { return \u0026lt;\u0026gt; \u0026lt;button onClick={this.","title":"關於 React Hooks 的 useState()"},{"content":"之後重寫！ Redux 是一個管理整個網站應用程式 state 的框架。\nstore 用來儲存管理應用程式的 state。\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-09-redux-overview/","summary":"之後重寫！ Redux 是一個管理整個網站應用程式 state 的框架。\nstore 用來儲存管理應用程式的 state。","title":"Redux 筆記"},{"content":"七月二十九號早晨七點四十四分，我在往高鐵路上出了小車禍。\n我騎著摩托車直線行使，對方是汽車在路邊停車起步往左。\n由於當天出門時間很早，路上車流很少，我的車速也就沒有像是在光復路騎得如此慢了。\n所以當我看到對方車子時已經來不及煞停，雖有減速仍是撞下去了。\n神奇的是，根據照片我當時機車是往左倒，然而我的挫傷和擦傷卻都發生在右手腳。\n但那都不是重點，這篇文章主要是要紀錄在這次車禍中我學到的事情。\n移車 車禍發生時，只有在以下條件下才能夠（且應該）移動車輛：\n 無人受傷、無人死亡 有人受傷但是當事人同意移動車輛  保險 發生車禍時，如果有保車險的話，就趕快聯絡保險公司辦理出險，這樣後續的所有事情都可以詢問保險以及交給他們處理。\n辦理出險時，需要攜帶：\n 保險人印章 行照 駕駛人駕照  和解 一般小車禍通常會走和解，如果有保險處理會簡單很多。 至於調解或提告部份我不熟悉就不多嘴了。\n以我的例子來說，根據初判表（警方筆錄後初步判斷，車禍後一個月可以申請，不具實質法律效力）\n未完\u0026hellip;\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-07-car-accident/","summary":"七月二十九號早晨七點四十四分，我在往高鐵路上出了小車禍。\n我騎著摩托車直線行使，對方是汽車在路邊停車起步往左。\n由於當天出門時間很早，路上車流很少，我的車速也就沒有像是在光復路騎得如此慢了。\n所以當我看到對方車子時已經來不及煞停，雖有減速仍是撞下去了。\n神奇的是，根據照片我當時機車是往左倒，然而我的挫傷和擦傷卻都發生在右手腳。\n但那都不是重點，這篇文章主要是要紀錄在這次車禍中我學到的事情。\n移車 車禍發生時，只有在以下條件下才能夠（且應該）移動車輛：\n 無人受傷、無人死亡 有人受傷但是當事人同意移動車輛  保險 發生車禍時，如果有保車險的話，就趕快聯絡保險公司辦理出險，這樣後續的所有事情都可以詢問保險以及交給他們處理。\n辦理出險時，需要攜帶：\n 保險人印章 行照 駕駛人駕照  和解 一般小車禍通常會走和解，如果有保險處理會簡單很多。 至於調解或提告部份我不熟悉就不多嘴了。\n以我的例子來說，根據初判表（警方筆錄後初步判斷，車禍後一個月可以申請，不具實質法律效力）\n未完\u0026hellip;","title":"車禍小記"},{"content":"https://www.youtube.com/watch?v=E_48TMCfBz8\n C++ 的 Zero Overhead\nhttps://www.zhihu.com/question/384653836\n 檔案系統、檔案處理的 library  原本是 boost 的，現在以今正式寫進 ISO 標準。\n可以把 boost 理解成 C++ 的 beta 版本\n nodiscards [[nodiscards]] int f() { return 30; } int main() { f(); return 0; } 函式回傳值完全沒有被使用，在編譯時會有 Warning。\nFold Expression 之後介紹\n\u0026lt;any\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;any\u0026gt; int main() { std::any a = 3; a = 3.2; a = std::string(\u0026quot;XD\u0026quot;); return 0; } \u0026lt;variant\u0026gt; 範圍 \u0026lt;string_view\u0026gt;\n \u0026ldquo;無\u0026quot;的概念\nstd::optional\u0026lt;int\u0026gt; a; if (a) { // a 有值 std::cout \u0026lt;\u0026lt; a.value() \u0026lt;\u0026lt; std::endl; } else { // a 沒有值 std::cout \u0026lt;\u0026lt; \u0026quot;a has no value\u0026quot; \u0026lt;\u0026lt; std::endl;q } ","permalink":"https://lnfu.github.io/blog/posts/2023-08-03-cpp-17/","summary":"https://www.youtube.com/watch?v=E_48TMCfBz8\n C++ 的 Zero Overhead\nhttps://www.zhihu.com/question/384653836\n 檔案系統、檔案處理的 library  原本是 boost 的，現在以今正式寫進 ISO 標準。\n可以把 boost 理解成 C++ 的 beta 版本\n nodiscards [[nodiscards]] int f() { return 30; } int main() { f(); return 0; } 函式回傳值完全沒有被使用，在編譯時會有 Warning。\nFold Expression 之後介紹\n\u0026lt;any\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;any\u0026gt; int main() { std::any a = 3; a = 3.2; a = std::string(\u0026quot;XD\u0026quot;); return 0; } \u0026lt;variant\u0026gt; 範圍 \u0026lt;string_view\u0026gt;\n \u0026ldquo;無\u0026quot;的概念","title":"C++ 17 變化"},{"content":"2023-08-03 tar 將多個文件打包（群組）成一個。\n沒有壓縮，所以通常會搭配 gzip 一起使用來壓縮檔案。\n打包並壓縮後的檔案副檔名會是 .tgz 或是 .tar.gz。\n流程如下：\nfile --(tar)--\u0026gt; file.tar --(gzip)--\u0026gt; file.tar.gz 解壓縮：\ntar xvzf file.tgz xargs 有點難解釋，忘記就看這篇吧，寫得蠻清楚的。\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-03-linux-trivials/","summary":"2023-08-03 tar 將多個文件打包（群組）成一個。\n沒有壓縮，所以通常會搭配 gzip 一起使用來壓縮檔案。\n打包並壓縮後的檔案副檔名會是 .tgz 或是 .tar.gz。\n流程如下：\nfile --(tar)--\u0026gt; file.tar --(gzip)--\u0026gt; file.tar.gz 解壓縮：\ntar xvzf file.tgz xargs 有點難解釋，忘記就看這篇吧，寫得蠻清楚的。","title":"Linux 相關小知識"},{"content":"React 是 Facebook 開發和維護的（Javascript）view library。\nJSX React 使用 JSX 語法，可以看成是 Javascript 的擴展，讓我們能夠在 Javascript 中寫 HTML 並保有像是程式語言（Javascript）的可程式化性質。\nJSX 檔案最終會由 Babel transcompiler 成真正的 Javscript 程式碼。\nclass 在 JSX 中由於是 Javascript 關鍵字所以變成 className。\nComponent component 概念可以說是 React 的核心。\n 個人觀點是這樣做使得 HTML 物件能夠輕鬆的被封裝、結構化、reuse\u0026hellip;\n 作為 componenet 的 class/function 名稱開頭必須大寫。\n寫法一（原生 Javascript 函數） const MyComponent = function() { return \u0026lt;div\u0026gt;Hello, World\u0026lt;/div\u0026gt; } 寫法二（使用 ES6 class 語法） class MyComponent extends React.Component { constructor(props) { super(props); } render() { return \u0026lt;div\u0026gt;Hello, World\u0026lt;/div\u0026gt; } }; ReactDOM ReactDOM 是用來 render JSX 物件或是 component 到 HTML DOM 的 API。\nReactDOM.render(componentToRender, targetNode) 例如：\nReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById('root')) Props（參數） 要如何在 component 之間傳遞參數呢（parent -\u0026gt; child）？答案是 Props（properties）。\n範例：\n\u0026lt;App\u0026gt; \u0026lt;CurrentDate date={Date()}/\u0026gt; \u0026lt;/App\u0026gt; const CurrentDate = (props) =\u0026gt; \u0026lt;p\u0026gt;The current date is: {props.date}\u0026lt;/p\u0026gt;  Date() 是 Javascript 的原生函數，會回傳當前時間。\n 另外，component 也可以設定 default props。\nMyComponenet.defaultProps = {name: \u0026quot;Enfu Liao\u0026quot;} PropTypes 我們可以強制規範 prop 的型別。\nhttps://legacy.reactjs.org/docs/typechecking-with-proptypes.html#proptypes\nclass MyCompo extends React.Component { constructor(props) { super(props); } render() { return \u0026lt;div\u0026gt;this.props.name\u0026lt;/div\u0026gt;; } } MyCompo.defaultProps = { name: \u0026quot;Enfu Liao\u0026quot; } MyCompo.propTypes = { name: PropTypes.string.isRequired }  除了常數以外，Props 還可以傳遞之後提到的 state 以及 member function（成員函數）\n state（狀態） React 的 virtual DOM 會看 state 資料是否有更新，如果有就會重新渲染部份頁面（actual DOM）。\nconstructor(props) { this.state = { name: \u0026quot;Enfu Liao\u0026quot; } } \u0026lt;div\u0026gt;this.state.name\u0026lt;/div\u0026gt; setState() 如果要更新 state 則必須使用 setState()：\nthis.setState({ name: \u0026quot;Enya Liao\u0026quot; })  要能夠使用到 this.state，class 的 method 比須加上 this.methodName = this.methodName.bind(this);和 class 綁定（詳細問題我目前不太清楚）\n  另外可能也需要複習一下 Javascript this 的使用時機（雖然也可以自己亂試解決）\n 有時候我們更新 state 會需要依賴原本 state 或是 props 的值，那麼就要採用以下寫法（因為更新是非同步（async），不能直接使用 this.state 或是 this.props）：\nthis.setState((state, props) =\u0026gt; ({ counter: state.counter + props.increment })); this.setState(state =\u0026gt; ({ counter: state.counter + 1 })); Lifecycle Method / Hook  可以 attach event listener。document.addEventListener('keydown', myFunc())、document.removeEventListener('keydown', myFunc())。\n 何時會重新算繪（re-render）？ 預設情況下，只要有 component 的 props 和 state 有更新，那麼這個 component 和其子代 component 都會重新算繪。\n利用 shouldComponentUpdate() 指定何時要重新算繪 條件算繪（condition rendering） 直接使用 if/else 在 render() 函數使用 if/else 來回傳不同 JSX。\n三元運算子 比較簡潔（推薦作法）\n使用 condition \u0026amp;\u0026amp; \u0026lt;...\u0026gt;\u0026lt;/...\u0026gt; 比較簡潔（推薦作法）\nServer Side Rendering 這是比較進階的議題了，之後在研究。\nReactDOMServer.renderToString(\u0026lt;App /\u0026gt;) ","permalink":"https://lnfu.github.io/blog/posts/2023-08-01-react-overview/","summary":"React 是 Facebook 開發和維護的（Javascript）view library。\nJSX React 使用 JSX 語法，可以看成是 Javascript 的擴展，讓我們能夠在 Javascript 中寫 HTML 並保有像是程式語言（Javascript）的可程式化性質。\nJSX 檔案最終會由 Babel transcompiler 成真正的 Javscript 程式碼。\nclass 在 JSX 中由於是 Javascript 關鍵字所以變成 className。\nComponent component 概念可以說是 React 的核心。\n 個人觀點是這樣做使得 HTML 物件能夠輕鬆的被封裝、結構化、reuse\u0026hellip;\n 作為 componenet 的 class/function 名稱開頭必須大寫。\n寫法一（原生 Javascript 函數） const MyComponent = function() { return \u0026lt;div\u0026gt;Hello, World\u0026lt;/div\u0026gt; } 寫法二（使用 ES6 class 語法） class MyComponent extends React.Component { constructor(props) { super(props); } render() { return \u0026lt;div\u0026gt;Hello, World\u0026lt;/div\u0026gt; } }; ReactDOM ReactDOM 是用來 render JSX 物件或是 component 到 HTML DOM 的 API。","title":"React 簡介"},{"content":"Font Awesome 提供很多好用的圖示（icon）。\n使用 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://use.fontawesome.com/releases/v5.8.1/css/all.css\u0026#34; integrity=\u0026#34;sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; 通常會使用在 \u0026lt;i\u0026gt;\u0026lt;/i\u0026gt; tag。例如 \u0026lt;i class=\u0026quot;fas fa-info-circle\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;。\n 可以到 https://fontawesome.com/icons 查詢要使用的 icon。\n 範例 \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-block btn-primary\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-thumbs-up\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Like\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-block btn-info\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-info-circle\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Info\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-block btn-danger\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-trash\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","permalink":"https://lnfu.github.io/blog/posts/2023-08-01-font-awesome/","summary":"Font Awesome 提供很多好用的圖示（icon）。\n使用 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://use.fontawesome.com/releases/v5.8.1/css/all.css\u0026#34; integrity=\u0026#34;sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; 通常會使用在 \u0026lt;i\u0026gt;\u0026lt;/i\u0026gt; tag。例如 \u0026lt;i class=\u0026quot;fas fa-info-circle\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;。\n 可以到 https://fontawesome.com/icons 查詢要使用的 icon。\n 範例 \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-block btn-primary\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-thumbs-up\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Like\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-block btn-info\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-info-circle\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Info\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;btn btn-block btn-danger\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-trash\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Delete\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ","title":"HTML 使用 Font Awesome 圖示"},{"content":"Bootstrap 是目前最受歡迎的 CSS framework（雖然近年來前端領域好像都在用 tailwind CSS）。\n使用 加入這行到 HTML 即可使用 Bootstrap。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;/\u0026gt; 把所有元素放到 \u0026lt;div class=\u0026quot;container-fluid\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;。\n 除了 container-fluid 以外還有像是 container、container-md、\u0026hellip;詳情請洽官方文檔說明\n 照片自動調整成符合視窗大小 \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;\u0026#34;\u0026gt; 文字樣式 \u0026lt;h2 class=\u0026#34;text-primary text-center\u0026#34;\u0026gt;your text\u0026lt;/h2\u0026gt; 如果要在內文強調可以用 \u0026lt;span class=\u0026quot;text-primary\u0026gt;\u0026lt;/span\u0026gt;。\n按鈕 \u0026lt;button class=\u0026#34;btn btn-default\u0026#34;\u0026gt;Like\u0026lt;/button\u0026gt; 所有按鈕都要有 btn attribute。btn-default 是按鈕的一種樣式（白底），也可使用 btn-primary（網站的主色彩）、btn-info、btn-danger（常用於 Delete）樣式。\n btn-default 好像在 Bootstrap 5 被拿掉了。\n 按鈕預設大小是包住按鈕中的文字，加上 btn-block attribute 就會變成 100% 的大小。\n格線系統 Bootstrap 的（響應式）格線系統有 12 欄。\ncol-md-4 =\u0026gt; median e.g., laptop col-xs-4 =\u0026gt; extra small e.g., mobile phone \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 表單 文字輸入可以用 form-control（會是 100% width）。Submit 按鈕一樣使用 btn 就好。\n如果想讓輸入框和 Submit 在同一行，一樣就用格線系統去包就好（比例可以參考文字框 col-7 + Submit col-5）。\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-01-bootstrap/","summary":"Bootstrap 是目前最受歡迎的 CSS framework（雖然近年來前端領域好像都在用 tailwind CSS）。\n使用 加入這行到 HTML 即可使用 Bootstrap。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;/\u0026gt; 把所有元素放到 \u0026lt;div class=\u0026quot;container-fluid\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;。\n 除了 container-fluid 以外還有像是 container、container-md、\u0026hellip;詳情請洽官方文檔說明\n 照片自動調整成符合視窗大小 \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;\u0026#34;\u0026gt; 文字樣式 \u0026lt;h2 class=\u0026#34;text-primary text-center\u0026#34;\u0026gt;your text\u0026lt;/h2\u0026gt; 如果要在內文強調可以用 \u0026lt;span class=\u0026quot;text-primary\u0026gt;\u0026lt;/span\u0026gt;。\n按鈕 \u0026lt;button class=\u0026#34;btn btn-default\u0026#34;\u0026gt;Like\u0026lt;/button\u0026gt; 所有按鈕都要有 btn attribute。btn-default 是按鈕的一種樣式（白底），也可使用 btn-primary（網站的主色彩）、btn-info、btn-danger（常用於 Delete）樣式。\n btn-default 好像在 Bootstrap 5 被拿掉了。\n 按鈕預設大小是包住按鈕中的文字，加上 btn-block attribute 就會變成 100% 的大小。\n格線系統 Bootstrap 的（響應式）格線系統有 12 欄。\ncol-md-4 =\u0026gt; median e.g., laptop col-xs-4 =\u0026gt; extra small e.","title":"Bootstrap 基本使用"},{"content":"今天是我生日（海綿寶寶梗圖）\n每年的生日好像都由方谷展叔叔送的卡片開始，他的小孩和我是同所國小。以前我的保險是向他購買，也是從那時開始每年都會收到他的手寫卡片，即便現在已經沒有購買保險。\n上禮拜和唯心以及唐禕、王俐雯去吃海底撈（算是慶祝唯心當天 TUM 的面試告一段落），結果沒想到唐禕竟然知道過幾天是我生日所以跟店員講要幫我慶生。老實說我蠻開心的，只是還是遵循著個人風格以及當前時代風氣。\n隔天就收到唯心跟我說他申請上 TUM management \u0026amp; technology 了。當下其實心情有點複雜，一方面身為朋友當然是希望她能夠申請上，尤其是她感覺沒有什麼退路了。另一方面卻又覺得自己的能力那麼好也懂得較多，為什麼好像別人可以到比較好的環境我卻還在這。我也知道這和性格有很大程度上的相關，並且直接放棄目前的學士學程客觀上不是太明智的選擇。目前只有希望過兩年能夠順利在台灣先取得不錯的工作存點錢和持續自學研究領域內容（maybe CS or Math），再去國外讀研究所。\n星期六原本要到台北參加 Coscup，結果一早出了小車禍。不只 Coscup 連星期天的舉重課都不能去了（已經三個禮拜沒上課了），今年生日也算是多災多難。\n上禮拜看了奧本海默，突然對於基礎科學又有點熱情跑出來（也可能是三分鐘熱度），加上前陣子看到 ChatGPT code interpreter 的功能如此強大，覺得純軟應用的技術難度好像越來越低了，所以也有點希望跑回去讀數學，不過也許只是我的胡思亂想罷了。\n總而言之，目前規劃雖稍有調整，大致還是維持不變：今年好好準備實習、明年好好準備研究（不過決定改去 CG 的實驗室）、兩年後在台灣找一個薪水不太低工時較晚的工作、之後在到國外讀研（以及可能的數學專業？）。\n","permalink":"https://lnfu.github.io/blog/posts/2023-08-01-jottings/","summary":"今天是我生日（海綿寶寶梗圖）\n每年的生日好像都由方谷展叔叔送的卡片開始，他的小孩和我是同所國小。以前我的保險是向他購買，也是從那時開始每年都會收到他的手寫卡片，即便現在已經沒有購買保險。\n上禮拜和唯心以及唐禕、王俐雯去吃海底撈（算是慶祝唯心當天 TUM 的面試告一段落），結果沒想到唐禕竟然知道過幾天是我生日所以跟店員講要幫我慶生。老實說我蠻開心的，只是還是遵循著個人風格以及當前時代風氣。\n隔天就收到唯心跟我說他申請上 TUM management \u0026amp; technology 了。當下其實心情有點複雜，一方面身為朋友當然是希望她能夠申請上，尤其是她感覺沒有什麼退路了。另一方面卻又覺得自己的能力那麼好也懂得較多，為什麼好像別人可以到比較好的環境我卻還在這。我也知道這和性格有很大程度上的相關，並且直接放棄目前的學士學程客觀上不是太明智的選擇。目前只有希望過兩年能夠順利在台灣先取得不錯的工作存點錢和持續自學研究領域內容（maybe CS or Math），再去國外讀研究所。\n星期六原本要到台北參加 Coscup，結果一早出了小車禍。不只 Coscup 連星期天的舉重課都不能去了（已經三個禮拜沒上課了），今年生日也算是多災多難。\n上禮拜看了奧本海默，突然對於基礎科學又有點熱情跑出來（也可能是三分鐘熱度），加上前陣子看到 ChatGPT code interpreter 的功能如此強大，覺得純軟應用的技術難度好像越來越低了，所以也有點希望跑回去讀數學，不過也許只是我的胡思亂想罷了。\n總而言之，目前規劃雖稍有調整，大致還是維持不變：今年好好準備實習、明年好好準備研究（不過決定改去 CG 的實驗室）、兩年後在台灣找一個薪水不太低工時較晚的工作、之後在到國外讀研（以及可能的數學專業？）。","title":"隨筆（2023-08-01）"},{"content":" LADR = Linear Algebra Done Right\n  Suppose $a$ and $b$ are real numbers, not both 0. Find real numbers $c$ and $d$ such that $$ \\frac{1}{a+ib} = c + id $$.   這個高中數學，略。\n Show that $$ \\frac{-1 + i\\sqrt{3}}{2} $$ is a cube root of 1.   這個也高中數學，略。\n Prove that if $a\\in F$, $v\\in V$, and $av = 0$, then $a = 0$ or $v = 0$   拆成兩個 case（$a = 0$ 和 $a \\neq 0$）\n如果 $a = 0$ 就直接結束。\n如果 $a \\neq 0$，$a$ 會有一個乘法反元素 $a^{-1}$ 使得 $a^{-1}a = 1$ $$v = 1v = (a^{-1}a)v = a^{-1}(av) = a^{-1}0 = 0$$ （使用到 associativity 結合律）\n Prove that $-(-v) = v$ for every $v\\in V$   一樣從 associativity 下手 $$-(-v) = (-1)(-1v) = ((-1)(-1))v = 1v = v$$\n For each of the following subsets of $F^{3}$, determine whether it is a subspace of $F^{3}$  (a) $${ (x_{1}, x_{2}, x_{3}) \\in F^{3} : x_{1} + 2x_{2} + 3x_{3} = 0 }$$ (b) $${ (x_{1}, x_{2}, x_{3}) \\in F^{3} : x_{1} + 2x_{2} + 3x_{3} = 4 }$$ (c) $${ (x_{1}, x_{2}, x_{3}) \\in F^{3} : x_{1}x_{2}x_{3} = 0 }$$ (d) $${ (x_{1}, x_{2}, x_{3}) \\in F^{3} : x_{1} = 5x_{3} }$$\n 這個太 trivial，答案是 O, X, X, O\n Prove that the intersection of any finite collection of subspaces of $V$ is a subspace of $V$   令 $U_{1}, U_{2}, \u0026hellip;, U_{n}$ 都是 $V$ 的 subspace\n令 $U = U_{1} \\cap U_{2} \\cap U_{3} \\cap \u0026hellip; \\cap U_{n}$\n 因為 $0 \\in U_{i}$ for $i = 1, 2, \u0026hellip;, n$，所以 $0 \\in U$ 證明加法封閉性：  令 $v, w \\in U$，那麼 $v, w \\in U_{i}$，因為 $U_{i}$ 都是 subspace 所以有封閉性（$v + w \\in U_{i}$），因此 $v + w \\in U$   證明乘法（scalar mulplication）封閉性：  令 $v \\in U$，那麼 $v \\in U_{i}$，$av \\in U_{i}$, $a \\in F$，因此 $av \\in U$     Give an example of a nonempty subset $U$ of $R^{2}$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $R^{2}$.   有加法封閉性和反元素，但不是 subspace。\n可以找一個沒有滿足 scalar mulplication 封閉性的例子。（e.g., 有理數）\n$$(1, 1) \\in Z^{2}$$ $$\\sqrt{2} (1, 1) = (\\sqrt{2}, \\sqrt{2}) \\notin Z^{2}$$\n Give an example of a nonempty subset $U$ of $R^{2}$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $R^{2}$.   這題也蠻簡單的，我們可以找兩條不同且通過原點的線的聯集\n最簡單的例子就是 $x = 0$ 和 $y = 0$ $$V = { (x, y) : x = 0 \\text{ or } y = 0 }$$ $$(1, 0) \\in V \\text{ and } (0, 1) \\in V \\text{ but } (1, 0) + (0, 1) = (1, 1) \\notin V$$\n Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.   這題的反例可以參考上題的解答。\n證明：\n可以先證明右到左，如果其中一個 subspace 只是另一個的子集，那麼聯集後就是比較大的 subspace（當然是 $V$ 的 subspace）\n左到右可以用反證法，假設 $U$ 和 $W$ 是 $V$ 的 subspace 且沒有包含，$U \\cup W$ 是 $V$ 的 subspace。\n也就是存在 $u$ 和 $w$ 滿足 $u \\in U$、$u \\notin W$、$w \\in W$、$w \\notin U$\n若 $u + w \\in U$ 則 $(u + w) + (-u) \\in U$，所以 $w \\in U$，矛盾。$u + w \\notin U$。\n同理 $u + w \\notin W$。\n因此 $u + w \\notin U \\cup W$（與假設矛盾）\n Suppose that $U$ is a subspace of $V$. What is $U + U$?   我有想到答案是 $U$ 但是沒寫出證明。\n證明：\n因為 $U$ 是 subspace 所以有封閉性，所以 $U + U \\subseteq U$\n因為 $u = u + 0$ 對所有 $u \\in U$ 又 $0 \\in U$，所以 $U \\subseteq U + U$\n Does the operation of addition on the subspaces of $V$ have an additive identity? Which subspaces have additive inverses?   一開始沒看懂題目。\n課本第一章已經定義了 subspace 的加法，題目問的是是否這樣的加法有單位元素和反元素\n單位元素是 ${0}$ $$U + {0} = {0} + U = U$$ 反元素的話只有 ${0}$ 有（他自己），因為 $$U + W = {0} \\implies U = {0} \\wedge W = {0}$$\n Prove or give a counter-example: If $U_{1}$, $U_{2}$, $W$ are subspaces of $V$ such that $$U_{1} + W = U_{2} + W$$ then $U_{1} = U_{2}$   錯誤。直接舉個反例\n$$W = (x, 0)$$ $$U_{1} = (0, y)$$ $$U_{2} = (x, x)$$\n Is the operation of addition on the subspaces of $V$ commutative? Associative?   這題也很直覺。\n假設 $v = u + w \\in U + W$，$u \\in U$ and $w \\in W$ where $U$ and $W$ are subspaces of $V$。\n$v = w + u \\in W + U$（commutative）\nassociateve 的部份也差不多，假設 $v = (u_{1} + u_{2}) + u_{3} \\in (U_{1} + U_{2}) + U_{3}$，以下省略。\n Suppose $U$ is the subspace of $P(F)$ consisting of all polynomials $p$ of the form $$p(z) = az^{2} + bz^{5}$$ where $a, b \\in F$. Find a subspace $W$ of $P(F)$ such that $P(F) = U \\oplus W$   這題可以很容易想到是要次方是 $2$ 和 $5$ 為 $0$ 其他任意。\n不過證明的部份稍嫌繁瑣了。\n大致絲路如下：\n 證明 $W$ 是 subspace  $0 \\in W$ closed under addition closed under scalar mulplication   $P(F) = U \\oplus W$ if and only if $P(F) = U + W \\wedge U \\cap W = {0}$（這個很重要）  $P(F) = U + W$ $U \\cap W = {0}$     Prove or give a counter-example: If $U_{1}$, $U_{2}$, $W$ are subspaces of $V$ such that $$V = U_{1} \\oplus W \\text{ and } V = U_{2} \\oplus W$$ then $U_{1} = U_{2}$   錯誤。同 12 的反例。\n ","permalink":"https://lnfu.github.io/blog/posts/2023-07-28-linear-algebra-done-right-chap01/","summary":"LADR = Linear Algebra Done Right\n  Suppose $a$ and $b$ are real numbers, not both 0. Find real numbers $c$ and $d$ such that $$ \\frac{1}{a+ib} = c + id $$.   這個高中數學，略。\n Show that $$ \\frac{-1 + i\\sqrt{3}}{2} $$ is a cube root of 1.   這個也高中數學，略。\n Prove that if $a\\in F$, $v\\in V$, and $av = 0$, then $a = 0$ or $v = 0$   拆成兩個 case（$a = 0$ 和 $a \\neq 0$）","title":"LADR 第一章習題"},{"content":"最近我在 CC 分配到的工作是 survey EDR solution。\n在文章開始之前，我先講一下一些相關的專有名詞，假設我們維護多台主機。\n HIDS（Host-Based Intrusion Detection System）：安裝在需要監控的主機上，當主機偵測到異常事件時，回傳資訊給管理者（預警）。 EDR（Endpoint Detection and Response）：除了回傳資訊以外更加積極，例如直接封鎖惡意軟體、用戶（active response） NTA（Network Traffic Analysis）：可以想成是在網路層面的 HIDS。 NDR（Network Detection and Response）：可以想成是在網路層面的 EDR。 XDR：同時監控檢測主機和網路，甚至進行比對。 SIEM：集中各種資安產品所收集到的資訊，透過預先設定好的規則來進行分析、預警甚至自動化腳本回應（active response）  學長說希望找到的產品符合以下條件：\n open source 能夠偵測異常網路流量 能夠偵測重要檔案被改動 能夠主動封鎖用戶  OSSEC 一開始我找到 OSSEC 這套軟體。\nOSSEC 支援多種系統\n並且有以下功能：\n file integrity 檢查 log 檢查 rootcheck（惡意軟體檢查）  除此之外還可以設定 active response 自動回應異常事件。\nWazuh 不過後來我看到了 Wazuh 這個專案。\nWazuh 可以看成是 OSSEC + OpenSearch + OpenSCAP 的組合。\nOSSEC 前面已經講過了，省略。\nOpenSearch 主要負責 Wazuh 的搜尋和 Web UI 部份（Kibana）\nOpenSCAP 的 SCAP 是指 Security Content Automation Protocol，主要用來衡量系統有沒有漏洞。\n Wazuh server = OSSEC + OpenSCAP Wazuh indexer + Wazuh dashboard = OpenSearch + Kibana + \u0026hellip;\n  2023-07-12 CC System Meeting：Wazuh 能不能和現有的 OpenSearch 集群做整合。\n  選擇 Wazuh 最大的好處是社群好像是目前看起來最活躍的，所以有什麼問題比較容易解決。\n 安裝 Wazuh 我目前使用 source code 安裝 Wazuh manager（Wazuh indexer 和 Wazuh dashboard 先不安裝）。\n安裝方式參考官方網站的說明文檔。\nserver 部份：\nyum install make cmake gcc gcc-c++ python3 python3-policycoreutils automake autoconf libtool openssl-devel yum-utils yum-config-manager --enable powertools yum install libstdc++-static -y yum install epel-release yum-utils -y yum-builddep python34 -y curl -Ls https://github.com/wazuh/wazuh/archive/v4.4.5.tar.gz | tar zx cd wazuh-4.4.5 ./install.sh 接著依照提示完成安裝即可（選擇 manager），我所有選項都選預設值。\nsystemctl start wazuh-manager agent 部份：\nyum install make gcc gcc-c++ python3 python3-policycoreutils automake autoconf libtool openssl-devel cmake yum-config-manager --enable powertools yum install libstdc++-static -y 接下來和 server 一樣把安裝檔案下載下來執行 install.sh 腳本（選擇 agent）依照提示安裝。\n不管是 server 或是 agent，設定檔（預設）會放在 /var/ossec/etc/ 下。\n 為什麼 server 和 agent 要分成兩個設定檔案？\n OSSIM  之後研究一下 OSSIM 是啥？\n ","permalink":"https://lnfu.github.io/blog/posts/2023-07-26-wazuh-overview/","summary":"最近我在 CC 分配到的工作是 survey EDR solution。\n在文章開始之前，我先講一下一些相關的專有名詞，假設我們維護多台主機。\n HIDS（Host-Based Intrusion Detection System）：安裝在需要監控的主機上，當主機偵測到異常事件時，回傳資訊給管理者（預警）。 EDR（Endpoint Detection and Response）：除了回傳資訊以外更加積極，例如直接封鎖惡意軟體、用戶（active response） NTA（Network Traffic Analysis）：可以想成是在網路層面的 HIDS。 NDR（Network Detection and Response）：可以想成是在網路層面的 EDR。 XDR：同時監控檢測主機和網路，甚至進行比對。 SIEM：集中各種資安產品所收集到的資訊，透過預先設定好的規則來進行分析、預警甚至自動化腳本回應（active response）  學長說希望找到的產品符合以下條件：\n open source 能夠偵測異常網路流量 能夠偵測重要檔案被改動 能夠主動封鎖用戶  OSSEC 一開始我找到 OSSEC 這套軟體。\nOSSEC 支援多種系統\n並且有以下功能：\n file integrity 檢查 log 檢查 rootcheck（惡意軟體檢查）  除此之外還可以設定 active response 自動回應異常事件。\nWazuh 不過後來我看到了 Wazuh 這個專案。\nWazuh 可以看成是 OSSEC + OpenSearch + OpenSCAP 的組合。\nOSSEC 前面已經講過了，省略。","title":"Wazuh 介紹"},{"content":"Hugo 是以 go 語言開發的靜態網頁生成器/框架，特色是速度非常快。\n安裝 Hugo 那至於要如何安裝 Hugo 呢，因為我的電腦是 Ubuntu 22.04，可以直接用 apt 來安裝。\napt install hugo 建立網站 在 Hugo 建立網站的方式也很簡單。\nhugo new site [path] 由於我想使用 GitHub Pages 託管我的靜態網站，所以我會先建立一個 GitHub Repo，然後 clone 到本地在建立網站。\ncd [path] hugo new site . --force  使用 --force 的原因是因為目錄不是空的（有 README.md、LICENSE 文件）\n 建立好後可以看到多出了許多目錄和檔案。我們可以先去下載自己喜歡的主題到 themes/ 中，然後在設定檔 config.toml 套用主題。\n# config.toml theme = \u0026#34;[主題名稱]\u0026#34; 撰寫文章 建立文章（網頁）的方式一樣是 hugo new。\nhugo new [檔名] 建立好的檔案會存放在 content/ 中，習慣上我們會把文章放在叫做 posts/（或是 blog/）的子目錄下方便管理。\nhugo new posts/[檔名] 我們會發現建立的檔案預設就有一些資訊，這是因為 Hugo 建立文章是把 archetypes/ 下的特定文件（e.g., default.md）作為範本。\n 我一般會讓檔名符合像是 2023-07-25-my-post.md 的格式。這樣在排序時就會依照日期，只使用 hyphen 和小寫字母比較不會出錯。\n 執行 在本地執行網站。\nhugo server Github Pages 未完\u0026hellip;\n","permalink":"https://lnfu.github.io/blog/posts/2023-07-25-hello-hugo/","summary":"Hugo 是以 go 語言開發的靜態網頁生成器/框架，特色是速度非常快。\n安裝 Hugo 那至於要如何安裝 Hugo 呢，因為我的電腦是 Ubuntu 22.04，可以直接用 apt 來安裝。\napt install hugo 建立網站 在 Hugo 建立網站的方式也很簡單。\nhugo new site [path] 由於我想使用 GitHub Pages 託管我的靜態網站，所以我會先建立一個 GitHub Repo，然後 clone 到本地在建立網站。\ncd [path] hugo new site . --force  使用 --force 的原因是因為目錄不是空的（有 README.md、LICENSE 文件）\n 建立好後可以看到多出了許多目錄和檔案。我們可以先去下載自己喜歡的主題到 themes/ 中，然後在設定檔 config.toml 套用主題。\n# config.toml theme = \u0026#34;[主題名稱]\u0026#34; 撰寫文章 建立文章（網頁）的方式一樣是 hugo new。\nhugo new [檔名] 建立好的檔案會存放在 content/ 中，習慣上我們會把文章放在叫做 posts/（或是 blog/）的子目錄下方便管理。\nhugo new posts/[檔名] 我們會發現建立的檔案預設就有一些資訊，這是因為 Hugo 建立文章是把 archetypes/ 下的特定文件（e.","title":"Hello, Hugo 利用 Hugo 建立自己的部落格"}]